# React는 어떻게 나오게 되었는가?

https://www.youtube.com/watch?v=8pDqJVdNa44


- 2010년대 초반 웹 어플리케이션 개발은 빠르게 진행된데 반해 규모가 커질수록 유지보수가 어려웠다.
- 이 측면에 MVC 아키텍처를 기반으로 UI를 관리했는데 문제점들이있었음.
  - 상태관리 어려움 - 여러 컴포넌트 간 상태 동기화가 어려웠다.
  - DOM 조작의 성능 문제 - DOM조작이 많아질수록 성능이 저하됨
  - 코드 복잡도 증가 - 파일이 분리되어있다보니 여러 파일을 관리하기 힘듬
- 조던 월크와 Fbolt(Functiona Bolt)  
  - UI를 하나의 상태 기반 함수로 정의하면 어떨까? 라는 아이디어에서 출발 - 리액트 초기버전
  - UI를 함수형 컴포넌트로 정의해 불변성 유지
  - 변경이 생기면 전체 UI를 다시 렌더링하는 단순한 로직
  - 페이스북 광고 대시보드에 처음 테스트 
- 가상 DOM의 도입
  - 기존 Fbolt의 문제점중 하나는 전체 UI를 다시 렌더링 하면 성능이 크게 저하됨
  - 메모리에 존재하는 가상의 DOM을 생성하여 UI를 관리하는 방식
  - UI가 변경될떄마다 새로운 가상 DOM을 생성하고, 이전 상태와 비교하여 변경된 부분만 실제 DOM에 반영
  - 결국 성능최적화, 디버깅과 유지보수가 쉬워짐
- 2012년 인스타그램과 통합
  - 많은 사용자 인터렉션(좋아요, 댓글, 사진업로드) 등 을 처리해야핬음
  - 기존 MVC로는 상태관리도 어렵고 UI동기화도 까다로웠음
  - 리액트의 단방향 데이터흐름과 가상DOM기반 렌더링이 적합
- 2013년 JSConf에서 리액트 오픈소스 공개
  - JSX문법이 별로라고함 -> 관심사의 분리 원칙과 정반대되는것이었다.
  - 리액트 컴포넌트 기반구조가 어색함
  - 시간이지나면서 HTML, js를 함께 작성할 수 있어 생산성이 높아졌다의 장점
  - 가상DOM 렌더링 최적화 방식이 읹어받기 시작
  - 넷플릭스, 에어비앤비, 우버 등 도입하면서 신뢰도 높아짐

### 느낀점
- 기존에 일일히 jquery같은 경우 DOM을 찾고 일일히 거기에 함수를 적용하고 하는방식이었던 반면, react는 useState를 사용해 상태가 변경될때마다 UI가 자동 업데이트되도록함
- 기존에 DOM을 일일히 조작하고, DOM을 건드리는 순간 많아지게되면 성능도저하되고, UI 하나만 변경되어도 전체를 렌더링해야하는 문제점익 기존에 있었다면 리액트의 가상DOM을 도입함으로써 진짜DOM과 가상DOM을 비교하게되고, 거기서 변경된 부분만 렌더링해준다는 개념

### 가상 DOM의 동작
1. 초기 렌더링
  - React.createElement()를 통해 가상 DOM트리를 생성 -> 실제 DOM에 렌더링
2. 상태 변경
  - useState, setState 등을 호출하면 새로운 가상DOM이 생성
3. 가상 DOM 비교
   - React는 이전 가상DOM과 새로운 가상DOM을 비교
   - 변경된 부분만 찾아서 업데이트 해야하는 부분 파악
4. 진짜 DOM 업데이트
  - 변경된 부분만 실제DOM에 적용(Patch)
  - 전체 다 그리는게 아니라 필요한 부분만 수정


### 배치처리
```typescript
function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
    setCount(count + 1);
    setCount(count + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>증가</button>
    </div>
  );
}
```
- 배치처리가 없다면,  setCount가 호출될때마다 리렌더링이 발생함->비효율적
- 여러개의 상태변경을 한번에 처리함 (React18이후 여러가지를 모아 한번의 렌더링만 발생)

### 차이비교알고리즘
 - react는 차이비교알고리즘과 배치처리를 통해 가상DOM과 실제 DOM을 비교하고 수행함
 - 규칙3가지가 존재
   - 같은 태그는 유지하고 속성만 변경한다.
   - 태그가 다르면 기존요소는 삭제해버리고 새로 생성한다.
   - key를 활용해 리스트 변경을 최적화한다. 

### 배열에서 key를 사용하는 이유
 - 불필요한 렌더링을 방지하기위해서 key를 사용하는것임
