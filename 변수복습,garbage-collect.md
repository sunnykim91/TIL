# 변수의 선언과 할당 과정을 살펴보자

## 원시값의 경우
<img src="https://github.com/user-attachments/assets/b49892ed-6153-4415-8d4c-f7864139b41b" width="900px" />

var num;  //  a라는 메모리 저장소에 공간을 확보
num = 10;  // 10을 다른 저장소에 저장하고, 거기를 num을 가르키게한다.
num = 1000; // 1000을 또 다른 저장소에 저장하고, 거기를 num이 가르키게한다.
변수는 값의 주소를 기억하는 저장소 

## 객체의 경우
- 객체의 타입은 동적으로 변화할 수 있다. 어느정도 메모리공간을 확보해야하는지 예측할 수 없으니, 런타임에 메모리공간을 확보하고, 메모리의 힙 영역에 저장된다.
- 값을 저장하는게 아니라 메모리 주소를 저장한다.
```typescript
let obj1 = { name: 'Kim' };  // heap메모리에 저장
let obj2 = obj1;  // obj2는 obj1과 동일한 객체를 참조, obj1,2는 Stack메모리에 생성되며, heap에 있는 동일한 객체를 가르킴

function updateObject(obj) {
    obj.name = 'Park';  // 원본 객체가 수정됨
}

updateObject(obj1);  // 함수에 객체를 전달 할때에는 실제 객체가 아닌 참조가 전달됨
console.log(obj1.name); // 'Park'
console.log(obj2.name); // 'Park'
```



## 가비지컬렉션과 알고리즘
- 우선 다른 저수준의 언어 c언어와 같은 언어는 메모리의 할당/해제를 컨트롤 할 수 있다.
- 자바스크립트 같은 고수준의 언어는 자동 메모리 관리 방법을 사용.
- 메모리 할당을 추적하고 할당된 메모리가 필요없어지면 회수하는 방식임
- Mark and Sweeep알고리즘
  - 루트(전역) 부터 시작하여 도달 가능한 모든 객체를 마킹하고, 객체 그래프를 순회하면서 참조된 객체를 확인 (mark)
  - 마킹되지 않은 객체를 메모리에서 제거, 마킹된 객체의 마크 제거, 메모리 파편화 정리(sweep)
- 가비지컬렉션은 언제하나?
  - 사용 가능한 메모리가 특정 임계값 이하 이거나, 할당된 메모리가 특정 임계값 이상 일때
  - 주기적으로 알아서 실행하게 하거나, chrome의 경우 window.gc()를 통해 명시적으로할수도있음
