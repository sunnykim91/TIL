# Hooks

## useActionState
- 폼 제출이나 버튼을 눌러 생기는 액션의 결과를 기반으로 state를 업데이트 할 수 있도록 제공함
- 기본 형태 :
- ```typescript
  const [state, formAction] = useActionState(action, initialState);
  ```
- action은 비동기 함수 여야한다. initalState는 초기 상태 값이다.
- state는 pending, data, error 등 액션의 상태를 나타내는 객체
- formAction은 action함수와 state를 연결한 새로운 함수 -> 폼이 제출되면 이 함수가 호출되고 함수의 결과가 state에 반영
- 동작 방식 :
  - 사용자가 폼을 제출하면 formAction함수가 호출
  - React는 상태를 pending으로 변경하고 컴포넌트를 리렌더링
  - 비동기 액션이 완료되면 결과에 따라 success 또는 error로 변경하고 다시 리렌더링
  - UI를 업데이트
  

## useCallback
- 메모이제이션 된 콜백 함수를 반환하는 훅, 컴포넌트가 리렌더링 될 떄마다 새함수 인스턴스가 생성되는것을 방지하고, 의존성 배열의 값이 변경될때만 새 콜백 함수를 생성
- 불필요한 리렌더링 방지 및 성능 최적화
- ```typesciprt
  const memoizedCallback = useCallback(fn, dependencies);
  ```
- fn 메모이제이션 하려는 콜백 함수, 의존성 배열의 값이 변경될때만 다시 생성
- dependencies: 이 배열의 항목이 변경될떄만 함수가 다시생성
- 주요 사용 사례
  - 자식 컴포넌트에 콜백을 전달할 때 불필요한 리렌더링 방지
  - 의존성 배열에 함수를 포함시킬때 무한 루프 방지
  - 이벤트 핸들러의 안정적인 참조 유지
- ```typescript
  // 매 렌더링마다 새로운 함수가 생성됨
  function Component() {
    const handleClick = () => {
      console.log('클릭됨');
    };
    
    return <ChildComponent onClick={handleClick} />;
  }

  // useCallback사용 
  function Component() {
    const handleClick = useCallback(() => {
      console.log('클릭됨');
    }, []); // 의존성이 없으므로 함수가 한 번만 생성됨
    
    return <ChildComponent onClick={handleClick} />;
  }
  ```
- 동작 방식
  - 첫번째 렌더링 시, 함수와 의존성 배열을 저장
  - 후속 렌더링에서는 의존성배열을 비교함(이전과 현재)
  - 의존성이 변경되지 않았다면, 이전 함수 반환
  - 의존성이 변경되었다면, 새 함수를 생성하고 저장한 후 반환
- useMemo는 호출한 함수의 결과값을 캐싱한다면 , useCallback은 함수 자체를 캐싱한다.
  - ```typescript
    // 내부 구현
    function useCallback(callback, deps) {
      return useMemo(() => callback, deps);
    }
    ```


## useContext
- Props drilling을 피할 수 있도록 Context API를 함수형컴포넌트에서 쉽게 사용할수있게 해주는 훅
- ```typescript
  const MyContext = React.createContext(defaultValue);

  <MyContext.Provider value={/* 어떤 값 */}>
    {/* 자식 컴포넌트 */}
  </MyContext.Provider>
  ```
- 동작과정
  - 컴포넌트가 렌더링 될 때 React는 컴포넌트 트리를 탐색하여 가장 가까운 Provider를 찾는다.
  - Provider가 발견되면 해당 Provider의 value속성을 반환한다.
  - 없으면 컨텍스트의 기본값을 반환한다.
  - React는 Provider의 value가 변경되면 이를 감지하고 해당 컨텍스트를 사용하는 모든 컴포넌트를 리렌더링 한다.


## useDebugValue
- 커스텀 훅의 디버깅 정보를 표시하는데 사용, React DevTools 가 필요하다.
- ```typescript
  useDebugValue(value, formatFn);
  ```
- value: React DevTools에 표시할 값, 커스텀 훅의 내부상태나 중요한 값이 될 수 있음
- formatFn: 값을 포맷팅하는 함수
- 커스텀 훅 내부에서만 사용해야함. 복잡한 로직이나 중요한 상태를 가진 재사용가능한 훅에 주로 사용


## useDeferredValue
- 지연된 복사본을 생성하는 훅, 새 콘텐츠가 로딩되는 동안 오래된 콘텐츠 표시, UI일부 리렌더링 지연하기
- ```typescript
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  ```
- value: 지연시키려는 값, 어느타입이건 올수있음
- 반환값: 지연된 값을 반환. 초기렌더링에서는 이값이 전달된 원래값과 동일, 값이 변경되면 우선 동일하게 렌더링하고 백그라운드에서 새값으로 업데이트
- 무거운 렌더링 최적화, 사용자 입력 처리
- 디바운싱, 스로틀링과의 차이
- 디바운싱은 타이핑을 멈출때까지 기다렸다가 목록을 업데이트
- 스로틀링은 가끔씩 목록을 업데이트
- useDeferredValue는 React자체와 깊게 통합되어 있고, 사용자의 기기에 맞게 조정되서 렌더링 최적화하는데 더 적합
- React가 큰목록을 리렌더링하는 도중에 사용자가 다른키 입력을 하면 React는 해당 리렌더링을 중단하고 키입력을 처리하고 백그라운드에서 렌더링을 한다. 하지만 디바운싱과 스로틀링은 키입력을 차단하는 순간을 지연할뿐이여서 불안정하다.
- useTransition은 상태 업데이트를 지연 / useDeferredValue는 값 자체를 지연
- 

## useEffect
- 사이드 이펙트를 수행하기 위한 훅이다. 비동기적으로 실행되며, 데이터 페칭, DOM조작 등 작업에사용
- componentDidMound, componentDidupdate, componenWillunmount와 유사한기능을 제공
- 콜백실행시점 : 컴포넌트의 첫번째 렌더링이 완료된 후 , 의존성 배열의 값이 변경된 렌더링이 완료된 후 
- 의존성 배열에 객체나 함수를 포함시킬때 주의사항 - 무한 루프 방지
- ```typescript
  // 잘못된 방법: 무한 루프 발생
  useEffect(() => {
    fetchData(options);
  }, [options]); // options는 매 렌더링마다 새로 생성됨
  
  // 올바른 방법
  const memoizedOptions = useMemo(() => options, [options.id]);
  useEffect(() => {
    fetchData(memoizedOptions);
  }, [memoizedOptions]);
  ```


## useId
- 접근성 속성에 필요한 고유ID를 생성하는 훅
- label과 폼컨트롤을 연결하거나, aria속성에 사용
- key로 사용해서는 안된다. 키는 데이터로부터 파생되어야한다.
- 서버-클라이언트 간 하이드레이션의 일관성을 위한 것이다.
- *하이드레이션: 서버가 렌더링한 HTML을 클라이언트가 받아서 리액트 앱으로 완성하는 과정.


## useImperativeHandle
- 부모 컴포넌트에 노출될 ref객체를 사용자 정의하는 훅
- ```typescript
  useImperativeHandle(ref, createHandle, dependencies);
  ```
- ref: forwardRef를 통해 전달받은 ref객체
- createHandle : 부모 컴포넌트에 노출할 인스턴스 값을 반환하는 함수
- dependencies: 의존성 배열
- 특정 DOM요소에 접근해야할때, 자식컴포넌트의 메소드를 부모 컴포넌트에서 호출해야할때 등 사용


## useInsertionEffect
- CSS-in-JS 라이브러리에서 스타일 시트 삽입
- 런타임에 스타일을 동적으로 생성하고 삽입해야하는 경우
- DOM레이아웃을 계산하기 전에 스타일을 삽입해야하는 경우
- useInsertionEffect는 DOM 변경 전에 실행 / useLayoutEffect는 DOM 변경 후, 브라우저가 화면을 그리기 전에 실행 / useEffect는 브라우저가 화면을 그린 후에 비동기적으로실행

## useLayoutEffect
- useEffect와 유사하나 실행 시점이 다름 / DOM업데이트 직 후 브라우저가 화면을 그리전에 동적으로 실행
- useayoutEffect는 성능이 저하될수있으므로 useEffect사용 권고
- 이유 : useLayoutEffect는 동기실행이므로 렌더링을 블로킹함. 이 훅 안에서 무거운 작업을 하면 렌더링 지연이 발생 / SSR에선 실행불가
- 언제사용하나? DOM이 그려지기 직전에 동기적으로 무언가를 조정해야할때. 엘리먼트 크기를 측정하고 바로 스타일을 수정할 필요가 있다던가, 스크롤 위치를 수정한다던가 등
- 
