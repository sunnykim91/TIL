## 웹사이트의 변천사 중 모듈이 나오게된 배경
- 웹사이트가 점점 더 복잡해짐에따라 필요한 코드의 양이 늘어났다.
- 더 많은 기능을 추가하고, 사용자와의 상호작용을 구현하기 위해 Javascript코드가 매우 커졌고, 이렇게 커진 코드를 잘 관리하기 위해 코드를 나누어 정리하는 모듈화가 필요해졌다.

## 모듈화의 방법
- 파일 분리를 통한 코드 관리 -> 전역 네임스페이스 오염 문제 발생 (서로 다른 파일에서 정의된 전역 변수와함수들이 서로 충돌)
- 즉시 실행 함수 표현식의 도입 -> 각 파일의 변수와 함수가 자신만의 스코프를 가짐으로써 네임스페이스 오염 방지
- 하지만, 모듈 간 의존성 관리와 코드 재사용성에 한계점

## CommonJS
- Node.js에서 CommonJs라는 모듈 시스템이 만들어짐(서버에서 만들어진 이유는 복잡한 로직이더 많았어서)
- require를 통해 가져오고, module.exports를 사용해 내보낸다.
- 브라우저에서는 CommmonJs를 지원하지 않았다. -> 번들러가 필요해졌다.

## 번들러의 기능
- 여러개의 Javascript파일과 리소스를 하나의 파일로 묶어주는 도구
- 주요기능
  - 모듈 처리 : CommonJs 모듈을 브라우저가 해석할 수 있는 형태로 변환해줌.
  - 네트워크 요청 : HTTP1.1에서 동시처리연결개수의 제한이있었는데, 통합함으로써 네트워크 요청횟수가 줄어듬.
  - 성능 최적화 : 코드압축, 공백제거, 주석제거, 변수명 축소 등 다양한 방법으로 성능 향상
 

## Webpack
- 모듈 번들러의 대표적인 도구, 수십개의 자바스크립트 파일로 구성된걸 하나의 파일로 합쳐 브라우저가 빠르게 로드할수있도록 도와줌
- 모듈 의존성 관리 - 의존관계를 분석해 올바른 순서로 결합
- 다양한 리소스 처리 - Js뿐만 아니라 css, 이미지, 폰트 등 모든 리소스를 모듈 단위로 관리
- 성능 최적화

## ESM
- import , export 키워드 활용
- 브라우저가 <script type="module"> 태그를 활용해 모듈을 불러올수있게함
- 한계
  - 네트워크 요청의 비효율성 : 각 모듈마다 개별적인 HTTP요청이 발생해 초기로딩시간이 증가함
  - 브라우저 호환성 제약 : 구형 브라우저에서는 ESM문법을 지원하지않음.
  - 개발 환경 한계 : npm 에서 제공되는 대다수 패키지가 CJS형태라 변환하기위한 번들러가 필요하다.
 
