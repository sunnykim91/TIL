## 변수 선언시 키워드 var, let, const

### var의 특징
- 함수 레벨 스코프 지원
- 변수 호이스팅 : 변수의 선언문이 코드의 선두로 끌어 올려진 것처럼 동작- 자바스크립트의 고유특징 
- var, let, const, function, class 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스 등)은 호이스팅 된다. -> 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문
- var scroe=80; 이라고 했을때 선언단계에서 메모리 a라는 주소에 undefined를 할당 후에 다른 b라는 주소에 80이라는 값을 할당한다.(새로운 메모리 확보, 재할당도 마찬가지)
- 위에예제에서 버려진 주소들을 가비지라고 하고 그 가비지컬렉터가 메모리 누수 방지를 위해 메모리를 사용할 수 있게 해제한다.
- 같은 스코프 내에서는 중복 선언이 허용된다.

### var의 어떠한 문제점이 있었나
1. 블록레벨 스코프를 지원하지를 않음 -> 유지보수가 어려움
   ```typescript
   if (true) {
      var a = 10; // 블록 내부에서 선언
    }
    console.log(a); // ✅ 10 (블록 밖에서도 접근 가능)
    ```
2. 호이스팅시 undefined로 초기화 되버림 -> 예측이 어려운 코드가되고, undefined라는 값이 사용될여지가있음
3. 같은 변수명으로 중복선언이 가능함

## let, const
- 둘다 블록레벨 스코프를 지원한다.
- let같은 경우 재할당이 가능하다.
- const는 변경이 필요없는 상수에 사용 / 아래와 같이 객체 속성 변경은 가능하다.
  - ```typescript
    const person = { name: "Alice" };
    person.name = "Bob"; // ✅ 가능 (객체 속성 변경 가능)
    console.log(person); // { name: "Bob" }
    ```
- TDZ 일시적 사각지대가 존재한다. 변수가 선언되었지만, 초기화 되기 전까지는 접근할 수 없기에 ReferenceError가 발생한다.


## JavaScript 변수 선언 방식과 실행 단계 비교

| 단계 | `var x = 10;` | `let x = 10;` / `const x = 10;` |
|------|----------------------------|--------------------------------|
| **변수 선언** | 호이스팅됨 (초기값 `undefined`) | 호이스팅됨 (TDZ 영역에 위치) |
| **초기화(값 할당 전)** | `undefined` 값 할당 | 아직 초기화되지 않음 (TDZ) |
| **초기화(값 할당 후)** | 값 할당 (`x = 10`) | 값 할당 (`x = 10`) |

### 📝 설명
- `var`은 **호이스팅될 때 `undefined`로 초기화**되므로, 선언 전에 접근 가능하지만 예상치 못한 동작이 발생할 수 있음.
- `let`과 `const`는 **TDZ(Temporal Dead Zone, 일시적 사각지대)**에 놓여 선언 전에 접근하면 `ReferenceError`가 발생함.
- `const`는 선언과 동시에 반드시 초기화해야 하며, 재할당이 불가능함.


## 런타임?
- 런타임 = 코드가 실행되는 시점
