# 깊은복사 vs 얕은복사
- 깊은복사는 객체의 실제 값을 복사 vs 얕은복사는 객체의 참조 값을 복사
- 기존값에 영향을 미치지 않는다 vs 기존값에 영향을 끼친다.
- 깊은 복사에방법중에  const copy = JSON.parse(JSON.stringify(object)); 하는 방법이 있음
  - 이 방법의 단점은 객체를 문자열로 바꿧다가 객체로 바꿔야해서 성능적으로 느리고 좋지않다.
  - 또한, undefined, 함수 같은 경우 완전 손실 -> JSON에서 지원하지 않는 사양
  - JSON은 트리구조만 지원하고 순환구조는 지원하지 않음. 그래서 순환객체인 경우 사용할수없음


## 예시
```typescript
const foo = { a: 'a', b: { c: 'c' } }
const bar = { ...foo }
```
- 메모리 할당
  - foo 객체:
    a: 원시값 'a'는 메모리에 직접 저장
    b: 객체 { c: 'c' }의 메모리 주소를 참조
  - bar 객체 (얕은 복사):
    a: 새로운 메모리에 'a' 복사
    b: foo.b가 가리키는 메모리 주소를 같이 참조

```typescript
bar.b.c = 'd'  // 중첩 객체 수정
```
b는 같은 메모리 주소를 참조하므로
foo.b.c와 bar.b.c가 모두 'd'로 변경됨

```typescript
bar.a = 1  // 1차원 프로퍼티 수정
```
a는 독립적인 메모리를 가지므로
foo.a는 'a' 유지, bar.a만 1로 변경


깊은 복사를 했다면:
```typescript
const deepBar = deepCopy(foo)
deepBar.b.c = 'd'
console.log(foo.b.c) // 'c' 유지
```

모든 depth의 객체가 새로운 메모리 공간에 할당
원본 객체와 완전히 독립적인 구조 형성



## 재귀와 반복문
# 깊은 복사 구현 방식 비교

| 특성 | 재귀 방식 | 반복문 방식 |
|------|-----------|-------------|
| 메모리 사용 | 콜스택 메모리 사용 (O(n)) | 고정 메모리 사용 (O(1)) |
| 성능 | 각 호출마다 컨텍스트 생성 비용 | 단일 컨텍스트에서 처리 |
| 코드 가독성 | 높음 (로직이 명확) | 상대적으로 복잡 |
| 유지보수성 | 구조 파악 용이 | 스택 관리 코드 필요 |
| 에러 위험 | 깊은 중첩시 스택오버플로우 | 안정적 |
| 확장성 | 구조 변경 용이 | 구조 변경 어려움 |

- 작은 객체: 재귀 (간단/명확)
- 큰 객체/깊은 중첩: 반복문 (안정성)
- 순환참조 처리: WeakMap 활용이 재귀에서 더 자연스러움


### 순환참조 객체의 사용
- 트리, 그래프 구조에서 부모-자식 순환참조 시에 사용
