# 깊은복사 vs 얕은복사
- 깊은복사는 객체의 실제 값을 복사 vs 얕은복사는 객체의 참조 값을 복사
- 기존값에 영향을 미치지 않는다 vs 기존값에 영향을 끼친다.
- 깊은 복사에방법중에  const copy = JSON.parse(JSON.stringify(object)); 하는 방법이 있음
  - 이 방법의 단점은 객체를 문자열로 바꿧다가 객체로 바꿔야해서 성능적으로 느리고 좋지않다.
  - 또한, undefined, 함수 같은 경우 완전 손실 -> JSON에서 지원하지 않는 사양
  - JSON은 트리구조만 지원하고 순환구조는 지원하지 않음. 그래서 순환객체인 경우 사용할수없음


## 예시
```typescript
const foo = { a: 'a', b: { c: 'c' } }
const bar = { ...foo }
```
- 메모리 할당
  - foo 객체:
    a: 원시값 'a'는 메모리에 직접 저장
    b: 객체 { c: 'c' }의 메모리 주소를 참조
  - bar 객체 (얕은 복사):
    a: 새로운 메모리에 'a' 복사
    b: foo.b가 가리키는 메모리 주소를 같이 참조

```typescript
bar.b.c = 'd'  // 중첩 객체 수정
```
b는 같은 메모리 주소를 참조하므로
foo.b.c와 bar.b.c가 모두 'd'로 변경됨

```typescript
bar.a = 1  // 1차원 프로퍼티 수정
```
a는 독립적인 메모리를 가지므로
foo.a는 'a' 유지, bar.a만 1로 변경


깊은 복사를 했다면:
```typescript
const deepBar = deepCopy(foo)
deepBar.b.c = 'd'
console.log(foo.b.c) // 'c' 유지
```

모든 depth의 객체가 새로운 메모리 공간에 할당
원본 객체와 완전히 독립적인 구조 형성


