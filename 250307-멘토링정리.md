# React에 관한 정리
- 리액트가 나오게된 배경이 뭘까? 리액트를 사용하면 정말 성능이 좋아지나?
- 리액트는 기본적으로 상태가 변경되면, DOM을 다시그리자는 것 부터 출발하였음.
- 하지만, 모든 DOM을 다 다시그리기에는 브라우저의 비용이 많이 들기때문에, 변경되는것만 다시 그리자해서 가상DOM개념이 도입됨
- 가상DOM은 메모리를 잡아먹기때문에 성능상 좋아진다는 말은 좀 맞지 않는다. 대신 다른 이점들이 존재하고 그 이점들이 이 단점을 상쇄한다.
- 초창기 웹은 DOM구조가 단순하기 떄문에 특정 태그를 찾아서 수정하고 하는게 번거롭지 않았으나, 현대의 웹은 매우 복잡하게 되어있어 찾고 수정하는 것 자체가 큰 비용이 되었음.
- 그래서 리액트는 그런 수고를 개발자들이 덜게 해주는 역할을 함. 즉, 너는 상태만 관리하면 UI에 대한 부분은 내가 알아서 잘 관리해줄게가 되었음.
- 개발자로 하여금 비즈니스 로직에 집중하게한다.

## 리액트의 장점
- 선언형(what)
  - 명령형(how)과 대비되는 개념
  - 개발자는 UI가 어떻게 보여야하는지만 선언하면, 상태변화에 따라 리액트가 알아서DOM을 업데이트함. DOM 조작로직을 작성할 필요가없다.
- 컴포넌트 기반
  - 재사용 가능한 조각으로 나눈다. 같은 컴포넌트를 여러곳에서 재사용한다. 유지보수도 쉬워지고, 테스트도 용이하다. 
- 한번 배워서 어디서나 사용가능하다.
  - 하나의 기술스택으로 여러플랫폼이 대응 가능하다. React native, React+Electron으로 데스크톱 앱, React460으로 VR 등 


### 라이브러리와 프레임워크
- 라이브러리는 내가 실행 하는 것 / 프레임워크는 내가 만든 것을 실행하는 것
- 리액트는 라이브러리 이지만, 컴포넌트의 생명주기와 상태관리에서 프레임워크적인 특성(제어의역전)을 보여준다.
- 리액트는 전체 어플리케이션 구조를 강제하진 않음. 개발자가 필요한 부분에만 리액트를 적용할 수 있음. 

### IoC 제어의 역전
- 프레임워크가 개발자의 코드를 호출한다. (일반적인 라이브러리에서는 개발자가 라이브러리를 호출하고 흐름을 직접 제어함)
- 개발자는 특정 인터페이스나 규약에 따라 코드를 작성
- 예시) 리액트의 useEffect
- useEffect에서의 제어의 역전:
- ```typescript
    function ExampleComponent({ id }) {
    const [data, setData] = useState(null);
    
    // 이펙트 훅 - 리액트가 언제 실행할지 결정함
    useEffect(() => {
      // 이펙트 함수
      const fetchData = async () => {
        const result = await api.getData(id);
        setData(result);
      };
      
      fetchData();
      
      // 클린업 함수
      return () => {
        // 정리 작업
        api.cancelRequest();
      };
    }, [id]); // 의존성 배열
    
    return <div>{data}</div>;
  }
  ```
 - 개발자는 무엇을 할지 정의합니다(이펙트 함수와 클린업 함수).
 - 리액트가 언제 이것을 실행할지 결정합니다
   - 컴포넌트 마운트 후
   - 의존성 배열의 값이 변경된 후
   - 컴포넌트 언마운트 전(클린업 함수)
 - 개발자는 의존성 배열을 통해 힌트만 제공할 뿐, 실제 실행 타이밍은 리액트가 관리합니다.


## 리액트의 라이프싸이클
mount :  컴포넌트 트리에 부착될때 = 컴포넌트 렌더링을 위해 최초 실행될 때
update : 리렌더링 조건에 의해 리렌더링이 일어날때
unmount : 컴포넌트 트리에서 뗴어질때 
