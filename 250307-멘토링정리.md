# React에 관한 정리
- 리액트가 나오게된 배경이 뭘까? 리액트를 사용하면 정말 성능이 좋아지나?
- 리액트는 기본적으로 상태가 변경되면, DOM을 다시그리자는 것 부터 출발하였음.
- 하지만, 모든 DOM을 다 다시그리기에는 브라우저의 비용이 많이 들기때문에, 변경되는것만 다시 그리자해서 가상DOM개념이 도입됨
- 가상DOM은 메모리를 잡아먹기때문에 성능상 좋아진다는 말은 좀 맞지 않는다. 대신 다른 이점들이 존재하고 그 이점들이 이 단점을 상쇄한다.
- 초창기 웹은 DOM구조가 단순하기 떄문에 특정 태그를 찾아서 수정하고 하는게 번거롭지 않았으나, 현대의 웹은 매우 복잡하게 되어있어 찾고 수정하는 것 자체가 큰 비용이 되었음.
- 그래서 리액트는 그런 수고를 개발자들이 덜게 해주는 역할을 함. 즉, 너는 상태만 관리하면 UI에 대한 부분은 내가 알아서 잘 관리해줄게가 되었음.
- 개발자로 하여금 비즈니스 로직에 집중하게한다.

## 리액트의 장점
- 선언형(what)
  - 명령형(how)과 대비되는 개념
  - 개발자는 UI가 어떻게 보여야하는지만 선언하면, 상태변화에 따라 리액트가 알아서DOM을 업데이트함. DOM 조작로직을 작성할 필요가없다.
- 컴포넌트 기반
  - 재사용 가능한 조각으로 나눈다. 같은 컴포넌트를 여러곳에서 재사용한다. 유지보수도 쉬워지고, 테스트도 용이하다. 
- 한번 배워서 어디서나 사용가능하다.
  - 하나의 기술스택으로 여러플랫폼이 대응 가능하다. React native, React+Electron으로 데스크톱 앱, React460으로 VR 등 


### 라이브러리와 프레임워크
- 라이브러리는 내가 실행 하는 것 / 프레임워크는 내가 만든 것을 실행하는 것
- 리액트는 라이브러리 이지만, 컴포넌트의 생명주기와 상태관리에서 프레임워크적인 특성(제어의역전)을 보여준다.
- 리액트는 전체 어플리케이션 구조를 강제하진 않음. 개발자가 필요한 부분에만 리액트를 적용할 수 있음. 

### IoC 제어의 역전
- 프레임워크가 개발자의 코드를 호출한다. (일반적인 라이브러리에서는 개발자가 라이브러리를 호출하고 흐름을 직접 제어함)
- 개발자는 특정 인터페이스나 규약에 따라 코드를 작성
- 예시) 리액트의 useEffect
- useEffect에서의 제어의 역전:
- ```typescript
    function ExampleComponent({ id }) {
    const [data, setData] = useState(null);
    
    // 이펙트 훅 - 리액트가 언제 실행할지 결정함
    useEffect(() => {
      // 이펙트 함수
      const fetchData = async () => {
        const result = await api.getData(id);
        setData(result);
      };
      
      fetchData();
      
      // 클린업 함수
      return () => {
        // 정리 작업
        api.cancelRequest();
      };
    }, [id]); // 의존성 배열
    
    return <div>{data}</div>;
  }
  ```
 - 개발자는 무엇을 할지 정의합니다(이펙트 함수와 클린업 함수).
 - 리액트가 언제 이것을 실행할지 결정합니다
   - 컴포넌트 마운트 후
   - 의존성 배열의 값이 변경된 후
   - 컴포넌트 언마운트 전(클린업 함수)
 - 개발자는 의존성 배열을 통해 힌트만 제공할 뿐, 실제 실행 타이밍은 리액트가 관리합니다.


## 리액트의 라이프싸이클
mount :  컴포넌트 트리에 부착될때 = 컴포넌트 렌더링을 위해 최초 실행될 때
update : 리렌더링 조건에 의해 리렌더링이 일어날때
unmount : 컴포넌트 트리에서 뗴어질때 


## 리액트에서 상태란?
- 상태라는 값이 변경이 되면 돔에도 업데이트를 시켜줘야하는 값을 상태라고한다.
![image](https://github.com/user-attachments/assets/cbd1c8d6-5b4a-4034-9b1e-2ee26c6b7635)

value2의 경우 - 계산결과값, 임시변수 등으로 사용 / 리렌더링이 일어났을때 변경이 되도 되는 것
value1의 경우 - 공유가 되는 값이므로 주로 상수를 넣는다.
value3의 경우 - 리렌더링을 해도 유지하고 싶을때

## 리렌더링의 조건
1. 상태 변경
2. props변경
3. 부모 컴포넌트의 리렌더링
4. forceUpdate호출
5. useSyncExternalStore - 외부 소스의 값이 변경될때도 나는 리렌더링을 시킬래

## 리액트에서 불변성이 중요한이유
 - 불변성 : 한번 생성된 데이터는 변경할 수 없다.
 - 리액트에서는 state, props 같은 데이터를 직접 수정하지 않고, 새로운 복사본을 만들어 사용한다.
 - ```typescript
   // ❌ 잘못된 방법 (불변성 위반)
    const updateUser = () => {
      user.name = "김철수";  // 원본 객체를 직접 수정
      setUser(user);
    };
    
    // ✅ 올바른 방법 (불변성 유지)
    const updateUser = () => {
      setUser({...user, name: "김철수"});  // 새 객체 생성
    };
   ```
 - 코드에서 setState(state => ({...state, b: 3})) 처럼 스프레드 연산자로 새 객체를 만들면
 - 내용은 거의 같지만 메모리 주소가 다른 새로운 객체가 생성됩니다.
 - 리액트는 이 참조 변화만 확인하고 "상태가 변경되었다"고 판단합니다.
 - 이후 렌더링 프로세스가 트리거됩니다.
 - 이러한 방식은 성능 최적화를 위해서이다. 모든 값을 비교하는 깊게 비교하는것은 비용이 많이 드니까, 리액트는 참조비교라는 간단한 방법으로 변경 사항을 감지한다.
 - 리액트에서 불변성이 중요한 이유는 얕은 비교 메커니즘이 제대로 작동하기 위해서입니다.
 - 항상 새 객체를 만들어 반환하는 불변성 패턴이 중요합니다. 리액트가 "뭔가 바뀌었구나!"라고 인식하게 해주는 신호가 바로 이 새로운 주소(참조)
