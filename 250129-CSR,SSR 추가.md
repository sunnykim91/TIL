### 브라우저가 크롤링을 한다라는 표현 x
- 크롤링은 검색 엔진의 크롤러가 웹사이트의 콘텐츠를 자동으로 탐색하고 수집하는 과정이므로, 검색엔진이 내 웹사이트를 크롤링한다가 맞는표현


### SEO에서 사이트맵이 필요한 이유
- 검색 엔진 크롤러가 내 사이트를 더 효과적으로 탐색하고 색인화 할 수 있도록 도와준다. 웹사이트 구조를 검색엔진에 알려주는거지.

### meta태그란?
- 메타데이터를 제공하는 태그. 검색엔진이 페이지를 이해하고 색인화하는데 도움을 주거나, 소셜미디어에서 링크 미리보기로 표시되는 정보를 조절할때 사용
- 메타데이터는 데이터를 설명하는 데이터이다.
- 예를들면, 이미지 파일의 경우는 파일크기,해상도, 촬영날짜 같은게 메타데이터 / 웹페이지는 제목,설명, 키워드, 작성자 같은게 메타데이터
- <meta name="description" content="이 웹사이트는 SEO와 웹 접근성에 대한 정보를 제공합니다.">  라고 하면, 검색엔진이 이 페이지의 내용을 요약해서 검색 결과에 표시할 수 있다.
- 메타 설명을 해주니까, 검색엔진이 내용을 이해하는데 도움을주고, 검색 결과에도 표시될수잇음.
- <meta property="og:title" content="SEO 가이드">
  <meta property="og:description" content="검색 엔진 최적화에 대한 완벽한 가이드">
  <meta property="og:image" content="https://example.com/image.jpg">
  이런것들은 링크 공유할때 미리보기 내용 설정 같은 걸 할수도있음.
- 즉 결과적으로 검색엔진이 내 사이트를 더 정확하게 분서갛고, 검색결과에서 더 눈에 띄게 만들수있음


### 시맨틱태그를 써야하는 이유
- SEO를 위하여, 웹 접근성을 위하여
- 왜 웹 접근성에서 필요한가?
  - 스크린 리더가 페이지 구조를 이해하기 쉽다. 예를들어 <nav>태그가 있으면 이건 네비게이션 메뉴입니다. 라고 안내할 수 있음.
  - <div> 태그 대신에 <button>태그를 쓰면 자동으로 키보드 포커스가 적용된다던가.
- 웹사이트를 더 잘 이해할 수 있다.


### SSR과 CSR은 로딩시간이 다르다던데, 어떤 로딩시간일까?
- Time to First Byte - 사용자가 브라우저에서 서버로 요청을 보내고, 서버가 첫 번째 응답 바이트를 반환하는 시간 = 서버가 얼마나 빨리 응답하느냐 = 네트워크 지연시간 + 서버 처리 시간
- TTFB의 경우 CSR, SSR 모두 영향을 받지만 SSR은 HTML을 서버에서 렌더링하므로 상대적으로 더 길어질 수 있다.
- First Contentful Paint - 화면에 최초의 콘텐츠가 렌더링 되는 시점 = 사용자가 아 화면에 뭐가 떳네 라고 느끼는 순간
- FCP의 경우 SSR은 서버에서 미리 HTML을 만들어 보내주므로, 브라우저가 빠르게 화면을 렌더링 할 수 있다 / CSR은 브라우저가 JS파일을 다운받고 실행한 후에야 콘텐츠를 그릴 수 있어서 상대적으로 느리다.
- Time to Interactive - 사용자가 페이지와 실제로 상호작용 할 수 있는 시점 = 버튼 클릭, 입력 상태
- TTI의 경우 SSR은 페이지 로딩 후에도 추가적으로 JS 다운로드 및 실행이 필요할 수 있음. CSR은 초기로딩이 느려도 , 일단 페이지가 뜨고나면 이후 라우팅이 빠르게 동작함.

### CSR이 무조건 느리다?
- CSR이 느리다고 하는 전제 조건
  - 1. 첫 번째 페이지 로드가 중요할때 - 초기에 JS파일을 다운받고 실행한 후에야 콘텐츠 표시해서 JS번들이 크면 초기 로딩이 엄청 느려질수있음.
    2. 네트워크 환경이 좋지 않을때 - 네트워크속도가 느리면 초기 로딩이 더 오래걸림. JS다운로드해야해서
    3. 서버가 빠를때 - 성능이 좋은 서버면 SSR은 HTML을 바로 생성해서 보내주니까 SSR이 더빠름
- CSR이 더 빠를 수도 있는 경우
  - 초기 로딩 이후의 페이지 전환이 중요할때


 ## CSR과 SSR의 렌더링 과정
 - CSR의 렌더링 과정
 - 사용자가 웹 사이트에 접속 - 브라우저가 index.html을 요청함 - 서버는 거의 빈 HTML을 반환함 - 브라우저가 HTML을 받아서 화면을 렌더링하려고하지만, 빈화면(컨텐츠가 없기때문에), JS파일 다운로드 , JS 실행 후 실제 콘텐츠가 렌더링 됨(hydration과정)
 - SSR의 렌더링 과정
 - 사용자가 웹 사이트 접속 - 브라우저가  index.html을 요청함 - 서버가 react컴포넌트를 실행하여, 완전한 HTML을 만든 후 반환, 브라우저가 HTML을 받자마자 화면에 즉시 렌더링, JS파일을 다운로드 후 Hydration과정 진행 

 
## JSX와 JSX의 렌더링
- JSX는 Javascript안에서 XML을 사용할 수 있도록 만든 문법 - React에서 UI를 만들 때 JSX를 사용하여 HTML을 javscript코드 안에서 작성 가능
```typescript
function App() {
  return (
    <div>
      <h1>안녕하세요, React!</h1>
      <p>JSX 문법을 사용하고 있어요.</p>
    </div>
  );
}
```
- jsx를 쓰지않으면 다음과 같이 써야함
```typescript
function App() {
  return React.createElement(
    "div",
    null,
    React.createElement("h1", null, "안녕하세요, React!"),
    React.createElement("p", null, "JSX 문법을 사용하지 않고 있어요.")
  );
}
```
- 브라우저가 직접 JSX를 해석하는게 불가 하기때문에 Babel이 Javscript코드로 변환해 줘야해.
- React는 JSX를 javascript코드로 변환해서 사용 가능하게 해주고, 가상DOM을 사용해 DOM조작을 최적화하여 성능을 높여주고, 변경된 부분만 업데이트하여 불필요한 리렌더링 방지해줌.
- 만약, 바닐라 자바스크립트를 사용한다면, craeteElement, innerHTML, appendChild 등을 활용해 직접 DOM을 변경해야하고, 매번 전체 DOM을 다시 그리거나, 불필요한 변경이 발생할 가능성이 커져 성능문제가 생길수있음.
